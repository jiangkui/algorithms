#《算法》（第四版）

[TOC]

#前言
- [随书配套网站地址：http://algs4.cs.princeton.edu/home/](http://algs4.cs.princeton.edu/home/)
- [github 项目地址：https://github.com/jiangkui/algorithms](https://github.com/jiangkui/algorithms)
- [常用数学符号的 LaTeX 表示方法](http://www.mohu.org/info/symbols/symbols.htm)

# 第 1 章 基础
`start:2015-11-26 08:00:00`
本书的目的是研究多种重要而实用的算法。和算法关系最紧密的是数据结构，
算法：适合用计算机实现的解决问题的方法。
数据结构：便于算法操作的组织数据的方法。

**1.1节** 介绍基础编程模型，总结了相关的语法、语言特性、和书中将会用到的库
**1.2节** 介绍数据抽象并定义抽象数据类型（ADT），进行模块化编程，抽象数据类型的过程，定义接口。
**1.3节** 学习三种基础的抽象数据类型：背包、队列和栈。
**1.4节** 描述了分析算法性能的方法。

## 算法

## 本书框架
本书讨论的算法都是数十年来研发的重要成果，他们将继续在快速发展的计算机应用中扮演重要角色。

### 第一章 基础
他讲解了在随后的章节中用来实现、分析和比较算法的基本原则和方法，包括 Java 编程模型、数据抽象、基本数据结构、集合类的抽象数据类型、算法性能分析的方法和一个案例分析。

### 第二章 排序
有序的重新排列数组中的元素是非常重要的基础算法。我们会深入研究各种排序算法，包括插入排序、选择排序、希尔排序、快速排序、归并排序和堆排序。同时我们还会讨论另外一些算法，它们用于解决几个与排序相关的问题，例如优先队列、选择以及归并。其中许多算法会成为后续章节中其他算法的基础。

### 第三章 查找
从庞大的数据集中找到制定的条目也是非常重要的。我们将会讨论基本的和高级的查找算法，包括二叉查找树、平衡查找树和散列表。我们会梳理这些方法之间的关系并比较他们的性能。

### 第四章 图
图的主要内容是对象和它们的链接，链接可能有权重和方向。利用图可以为大量重要而困难的问题建模，因此图算法的设计也是本书的一个重要研究领域。我们会研究深度优先搜索、广度优先搜索、连通性问题以及若干其他算法和应用，包括 Kruskal 和 Prim 的最小生成树算法、 Dijkstra 和 Bellman-Ford 的最短路径算法。

### 第五章 字符串
字符串是现代应用程序中的重要数据类型。我们将会研究一系列处理字符串的算法，首先是对字符串键的排序和查找的快速算法，然后是子字符串查找、正则表达式模式匹配和数据压缩算法。此外，在分析一些本身就十分重要的基础问题之后，这一章对相关领域的前沿话题也作了介绍。

### 第六章 背景
这一张将讨论于本书内容有关的若干其他前沿研究领域，包括科学计算、运筹学和计算理论。我们会介绍性地讲一下基于事件的模拟、B 树、后缀数组、最大流量问题以及其他高级主题，以帮助读者理解算法在许多有趣的前言研究领域中所起到的巨大作用。随后，我们会讲一讲搜索问题、问题转换和 NP 完全性等算法研究的支柱理论，以及他们和本书内容的联系。
	
**学习算法是非常有趣和令人激动的，**因为这是一个历久弥新的新领域（我们学习的绝大多数算法都还不到“五十岁”，有些还是最近才发明的，但也有一些算法已经有数百年的历史）。这个领域不断有新的发现，但研究透彻的算法仍然是少数。本书中既有精巧、复杂和高难度的算法，也有优雅、朴素和简单的算法。在科学和商业应用中，我们的目标是理解前者并熟悉后者，这样才能掌握这些有用的工具并学会算法式思考，以迎接未来计算任务的挑战。

`end:2015-11-26 09:24:00`

## 1.1 基础编程模型
`start:2015-11-27 12:29`

我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为**基础编程模型**。

### 1.1.1 Java 程序的基本结构


#### 1.1.7.3 我们的标准库
随机数静态方法库：StdRandom
数据分析静态方法库：StdStats 

#### 1.1.9.7 标准绘图库
绘图API：StdDraw

### 1.1.10 二分查找
`end:2015-11-27 13:00:00`
`start:2015-11-27 18:13:00`
[github 项目地址：https://github.com/jiangkui/algorithms](https://github.com/jiangkui/algorithms)

### 答疑

### 练习
跳过

`end:2015-11-27 19:14`

## 1.2 数据抽象
`start:2015-11-28 10:06`

## 1.3 背包、队列和栈
背包：一种不支持删除操作的集合。它的目的是 收集元素并能迭代元素。

#### 1.3.1.5 先进先出队列（简称：队列）
一种基于先进先出策略的集合类型

#### 1.3.1.6 下压栈（简称：栈）
一种基于后进先出策略的集合类型。

#### 1.3.1.7 算术表达式求值
如何才能够得到一个（由字符串表示的）算术表达式的值呢？
E.W.Dijkstra 在 20 世纪 60年代发明了一个非常简单的算法：用两个栈（一个用于保存运算符，一个用于保存操作数）完成了这个任务。P79

### 1.3.4 综述

## 1.4 算法分析

### 1.4.3 数学模型


### 1.4.4 增长数量级的分类
常数级别
对数级别
线性级别
线性对数级别
平方级别
立方级别
指数级别

## 1.5 案例研究 union-find 算法
我们的目的是强调以下几点：
- 优秀的算法因为能够解决实际问题而变得更为重要
- 高效算法的代码也可以很简单
- 理解某个实现的性能特点是一项有趣而令人满足的挑战
- 在解决同一个问题的多种算法之间进行选择时，科学方法是一种重要的工具
- 迭代式改进能够让算法的效率越来越高。

### 1.5.1 动态连通性

### 1.5.3 展望
只要可能我们在本书中研究各种基础问题时都会遵循类似于本节中讨论 union-find 问题时的基本步骤，在这里我们要再次强调他们。
- 完整而详细地定义问题，找出解决问题所必须的基本抽象操作并定义一份 API
- 简洁的实现一种初级算法，给出一个精心组织的开发用例并使用实际数据作为输入
- 当实现所能解决的问题的最大规模达不到期望时决定改进还是放弃
- 逐步改进实现，通过经验性分析或数学分析验证改进后的效果
- 用更高层次的抽象表示数据结构或算法来设计更高级的改进版本
- 如果可能尽量为最坏情况下的性能提供保证，但在处理普通数据时也要有良好的性能
- 在适当的时候将更细致的深入研究留给有经验的研究者并解决下一个问题。

设计高效的算法是一种很有成就感的智力活动，同时也能够产生直接的实际效益。

# 第 2 章 排序
现在计算机的广泛使用似的数据无处不在，而整理数据的第一步通常就是进行排序。
排序在商业数据处理和现代科学计算中有着重要的地位，它能够应用于事物处理、组合优化、天体物理学、分子动力学、语言学、基因组学、天气预报和很多其他领域。

其中，快速排序 甚至被誉为 20 世纪科学和工程领域的十大算法之一。

本章中我们将学习集中经典的排序算法，并高效的实现了“优先队列”这种基础数据类型。我们将讨论比较排序算法的理论基础并在本章结尾总结若干排序算法和优先队列的应用。

## 2.1 初级排序算法

`start:2015-11-30 08:36`
### 2.1.2 选择排序
`思想：`找到最小的那个元素，与数组的第一个元素交换。重复。

`特点：`
- 运行时间和输入无关：已经排好序的数组和一个随机排列的数组花费时间相同。
- 移动数据少：每次交换都会改变两个数组元素的值。

```java
    public void sort(Comparable[] a) {
        int size = a.length;
        for (int i = 0; i < size; i++) {
            int min = i;
            for (int j = i + 1; j < size; j++) {
                if (less(a[j], a[min])) {
                    min = j;
                }
            }
            exch(a, i, min);
        }
    }
```

### 2.1.3 插入排序
`思想：`像人们整理扑克牌的方式一样，将每一张牌插入到手中牌的适当位置。
拿到一个值，与左侧的值依次比较，如果小于当前值，则交换位置，
`特点：`插入排序所需的时间取决于输入中元素的初始顺序，如果一个数组已经有序或者接近有序，那么插入排序将比其他排序快得多。

```java
    public void sort(Comparable[] a) {
        int size = a.length;
        for (int i = 1; i < size; i++) {
            for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                exch(a, j, j - 1);
            }
        }
    }
```

插入排序适用场景：
- 数组中每个元素距离它的最终位置都不远
- 一个有序的大数组接一个小数组
- 数组中只有几个元素的位置不正确

当倒置的输了很少时，插入排序很可能比本章中的其他任何算法都快。


### 2.1.4 排序算法的可视化

### 2.1.5 比较两种排序算法
`start:2015-11-30 21:30`

本节主要了解如何科学的比较排序算法的性能，我们通过以下步骤比较两个算法：
- 实现并调试他们
- 分析他们的基本性质
- 对他们的相对性能做出猜想
- 用实验验证我们的猜想

只有研究那些最重要的算法的专家才会经历完整的研究过程，但每个使用算法的程序员都应该了解算法的性能特性背后的科学过程。

比较两种排序算法的性能类  SortCompare
[详细代码：参见GitHub](https://github.com/jiangkui/algorithms/blob/master/src/main/java/com/ljkdream/two/SortCompare.java)

### 2.1.6 希尔排序
`end:2015-11-30 22:54`
`start:2015-12-01 12:30`
`思想：`使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。
插入排序之所以慢是因为：他只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。 希尔排序就是让这个移动加快一些。

```java
   public void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        while (h < N / 3) {
            h = 3 * h + 1;
        }

        while (h >= 1) {
            //将数组变为 h 有序，数组中任意间隔为 h 的元素都是有序的
            for (int i = h; i < N; i++) {

                //将 a[i] 与 a[i-h] a[i-2*h] a[i-3*h]... 比较
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h) {
                    exch(a, j, j - h);
                }
            }
            h = h / 3;
        }
    }
```

希尔排序的递增序列如何选择？
这是个研究性的问题。。。尚未有那个大神证明出某个序列是最好的。

希尔排序也可以用于大型数组。
有经验的程序员有时会选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。

下面的几节我们会看到更加高效的算法，但除了对于很大的N，他们可能只会比希尔排序快两倍（可能还达不到），而且更加复杂。如果你需要解决一个排序问题而又没有系统排序函数可用，可以先用希尔排序，然后再考虑是否值得将它替换为更复杂的排序算法。

`end:2015-12-01 13:08`

## 2.2 归并排序
`start:2015-12-01 22:49`
`思想：`要将一个大数组排序，可以将它分成两半分别排序，然后将结果归并起来。

`缺点：`需要额外的空间
`时间复杂度：`$N \log N$

### 2.2.1 原地归并的抽象方法
