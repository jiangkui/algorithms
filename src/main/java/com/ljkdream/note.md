#《算法》（第四版）

[TOC]

#前言
- [随书配套网站地址：http://algs4.cs.princeton.edu/home/](http://algs4.cs.princeton.edu/home/)
- [github 项目地址：https://github.com/jiangkui/algorithms](https://github.com/jiangkui/algorithms)
- [常用数学符号的 LaTeX 表示方法](http://www.mohu.org/info/symbols/symbols.htm)

# 第 1 章 基础
`start:2015-11-26 08:00:00`
本书的目的是研究多种重要而实用的算法。和算法关系最紧密的是数据结构，
算法：适合用计算机实现的解决问题的方法。
数据结构：便于算法操作的组织数据的方法。

**1.1节** 介绍基础编程模型，总结了相关的语法、语言特性、和书中将会用到的库
**1.2节** 介绍数据抽象并定义抽象数据类型（ADT），进行模块化编程，抽象数据类型的过程，定义接口。
**1.3节** 学习三种基础的抽象数据类型：背包、队列和栈。
**1.4节** 描述了分析算法性能的方法。

## 算法

## 本书框架
本书讨论的算法都是数十年来研发的重要成果，他们将继续在快速发展的计算机应用中扮演重要角色。

### 第一章 基础
他讲解了在随后的章节中用来实现、分析和比较算法的基本原则和方法，包括 Java 编程模型、数据抽象、基本数据结构、集合类的抽象数据类型、算法性能分析的方法和一个案例分析。

### 第二章 排序
有序的重新排列数组中的元素是非常重要的基础算法。我们会深入研究各种排序算法，包括插入排序、选择排序、希尔排序、快速排序、归并排序和堆排序。同时我们还会讨论另外一些算法，它们用于解决几个与排序相关的问题，例如优先队列、选择以及归并。其中许多算法会成为后续章节中其他算法的基础。

### 第三章 查找
从庞大的数据集中找到制定的条目也是非常重要的。我们将会讨论基本的和高级的查找算法，包括二叉查找树、平衡查找树和散列表。我们会梳理这些方法之间的关系并比较他们的性能。

### 第四章 图
图的主要内容是对象和它们的链接，链接可能有权重和方向。利用图可以为大量重要而困难的问题建模，因此图算法的设计也是本书的一个重要研究领域。我们会研究深度优先搜索、广度优先搜索、连通性问题以及若干其他算法和应用，包括 Kruskal 和 Prim 的最小生成树算法、 Dijkstra 和 Bellman-Ford 的最短路径算法。

### 第五章 字符串
字符串是现代应用程序中的重要数据类型。我们将会研究一系列处理字符串的算法，首先是对字符串键的排序和查找的快速算法，然后是子字符串查找、正则表达式模式匹配和数据压缩算法。此外，在分析一些本身就十分重要的基础问题之后，这一章对相关领域的前沿话题也作了介绍。

### 第六章 背景
这一张将讨论于本书内容有关的若干其他前沿研究领域，包括科学计算、运筹学和计算理论。我们会介绍性地讲一下基于事件的模拟、B 树、后缀数组、最大流量问题以及其他高级主题，以帮助读者理解算法在许多有趣的前言研究领域中所起到的巨大作用。随后，我们会讲一讲搜索问题、问题转换和 NP 完全性等算法研究的支柱理论，以及他们和本书内容的联系。
	
**学习算法是非常有趣和令人激动的，**因为这是一个历久弥新的新领域（我们学习的绝大多数算法都还不到“五十岁”，有些还是最近才发明的，但也有一些算法已经有数百年的历史）。这个领域不断有新的发现，但研究透彻的算法仍然是少数。本书中既有精巧、复杂和高难度的算法，也有优雅、朴素和简单的算法。在科学和商业应用中，我们的目标是理解前者并熟悉后者，这样才能掌握这些有用的工具并学会算法式思考，以迎接未来计算任务的挑战。

`end:2015-11-26 09:24:00`

## 1.1 基础编程模型
`start:2015-11-27 12:29`

我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为**基础编程模型**。

### 1.1.1 Java 程序的基本结构


#### 1.1.7.3 我们的标准库
随机数静态方法库：StdRandom
数据分析静态方法库：StdStats 

#### 1.1.9.7 标准绘图库
绘图API：StdDraw

### 1.1.10 二分查找
`end:2015-11-27 13:00:00`
`start:2015-11-27 18:13:00`
[github 项目地址：https://github.com/jiangkui/algorithms](https://github.com/jiangkui/algorithms)

### 答疑

### 练习
跳过

`end:2015-11-27 19:14`

## 1.2 数据抽象
`start:2015-11-28 10:06`

## 1.3 背包、队列和栈
背包：一种不支持删除操作的集合。它的目的是 收集元素并能迭代元素。

#### 1.3.1.5 先进先出队列（简称：队列）
一种基于先进先出策略的集合类型

#### 1.3.1.6 下压栈（简称：栈）
一种基于后进先出策略的集合类型。

#### 1.3.1.7 算术表达式求值
如何才能够得到一个（由字符串表示的）算术表达式的值呢？
E.W.Dijkstra 在 20 世纪 60年代发明了一个非常简单的算法：用两个栈（一个用于保存运算符，一个用于保存操作数）完成了这个任务。P79

### 1.3.4 综述

## 1.4 算法分析

### 1.4.3 数学模型


### 1.4.4 增长数量级的分类
常数级别
对数级别
线性级别
线性对数级别
平方级别
立方级别
指数级别

## 1.5 案例研究 union-find 算法
我们的目的是强调以下几点：
- 优秀的算法因为能够解决实际问题而变得更为重要
- 高效算法的代码也可以很简单
- 理解某个实现的性能特点是一项有趣而令人满足的挑战
- 在解决同一个问题的多种算法之间进行选择时，科学方法是一种重要的工具
- 迭代式改进能够让算法的效率越来越高。

### 1.5.1 动态连通性

### 1.5.3 展望
只要可能我们在本书中研究各种基础问题时都会遵循类似于本节中讨论 union-find 问题时的基本步骤，在这里我们要再次强调他们。
- 完整而详细地定义问题，找出解决问题所必须的基本抽象操作并定义一份 API
- 简洁的实现一种初级算法，给出一个精心组织的开发用例并使用实际数据作为输入
- 当实现所能解决的问题的最大规模达不到期望时决定改进还是放弃
- 逐步改进实现，通过经验性分析或数学分析验证改进后的效果
- 用更高层次的抽象表示数据结构或算法来设计更高级的改进版本
- 如果可能尽量为最坏情况下的性能提供保证，但在处理普通数据时也要有良好的性能
- 在适当的时候将更细致的深入研究留给有经验的研究者并解决下一个问题。

设计高效的算法是一种很有成就感的智力活动，同时也能够产生直接的实际效益。

# 第 2 章 排序
现在计算机的广泛使用似的数据无处不在，而整理数据的第一步通常就是进行排序。
排序在商业数据处理和现代科学计算中有着重要的地位，它能够应用于事物处理、组合优化、天体物理学、分子动力学、语言学、基因组学、天气预报和很多其他领域。

其中，快速排序 甚至被誉为 20 世纪科学和工程领域的十大算法之一。

本章中我们将学习集中经典的排序算法，并高效的实现了“优先队列”这种基础数据类型。我们将讨论比较排序算法的理论基础并在本章结尾总结若干排序算法和优先队列的应用。

## 2.1 初级排序算法

`start:2015-11-30 08:36`
### 2.1.2 选择排序
`思想：`找到最小的那个元素，与数组的第一个元素交换。重复。

`特点：`
- 运行时间和输入无关：已经排好序的数组和一个随机排列的数组花费时间相同。
- 移动数据少：每次交换都会改变两个数组元素的值。

```java
    public void sort(Comparable[] a) {
        int size = a.length;
        for (int i = 0; i < size; i++) {
            int min = i;
            for (int j = i + 1; j < size; j++) {
                if (less(a[j], a[min])) {
                    min = j;
                }
            }
            exch(a, i, min);
        }
    }
```

### 2.1.3 插入排序
`思想：`像人们整理扑克牌的方式一样，将每一张牌插入到手中牌的适当位置。
拿到一个值，与左侧的值依次比较，如果小于当前值，则交换位置，
`特点：`插入排序所需的时间取决于输入中元素的初始顺序，如果一个数组已经有序或者接近有序，那么插入排序将比其他排序快得多。

```java
    public void sort(Comparable[] a) {
        int size = a.length;
        for (int i = 1; i < size; i++) {
            for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                exch(a, j, j - 1);
            }
        }
    }
```

插入排序适用场景：
- 数组中每个元素距离它的最终位置都不远
- 一个有序的大数组接一个小数组
- 数组中只有几个元素的位置不正确

当倒置的输了很少时，插入排序很可能比本章中的其他任何算法都快。


### 2.1.4 排序算法的可视化

### 2.1.5 比较两种排序算法
`start:2015-11-30 21:30`

本节主要了解如何科学的比较排序算法的性能，我们通过以下步骤比较两个算法：
- 实现并调试他们
- 分析他们的基本性质
- 对他们的相对性能做出猜想
- 用实验验证我们的猜想

只有研究那些最重要的算法的专家才会经历完整的研究过程，但每个使用算法的程序员都应该了解算法的性能特性背后的科学过程。

比较两种排序算法的性能类  SortCompare
[详细代码：参见GitHub](https://github.com/jiangkui/algorithms/blob/master/src/main/java/com/ljkdream/two/SortCompare.java)

### 2.1.6 希尔排序
`end:2015-11-30 22:54`
`start:2015-12-01 12:30`
`思想：`使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。
插入排序之所以慢是因为：他只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。 希尔排序就是让这个移动加快一些。

```java
   public void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        while (h < N / 3) {
            h = 3 * h + 1;
        }

        while (h >= 1) {
            //将数组变为 h 有序，数组中任意间隔为 h 的元素都是有序的
            for (int i = h; i < N; i++) {

                //将 a[i] 与 a[i-h] a[i-2*h] a[i-3*h]... 比较
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h) {
                    exch(a, j, j - h);
                }
            }
            h = h / 3;
        }
    }
```

希尔排序的递增序列如何选择？
这是个研究性的问题。。。尚未有那个大神证明出某个序列是最好的。

希尔排序也可以用于大型数组。
有经验的程序员有时会选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。

下面的几节我们会看到更加高效的算法，但除了对于很大的N，他们可能只会比希尔排序快两倍（可能还达不到），而且更加复杂。如果你需要解决一个排序问题而又没有系统排序函数可用，可以先用希尔排序，然后再考虑是否值得将它替换为更复杂的排序算法。

`end:2015-12-01 13:08`

## 2.2 归并排序
`start:2015-12-01 22:49`
`思想：`要将一个大数组排序，可以将它分成两半分别排序，然后将结果归并起来。

`缺点：`需要额外的空间
`时间复杂度：`$N \log N$

### 2.2.1 原地归并的抽象方法
```java
public class Magre extends AbstractSortExample {

    private Comparable[] aux; //归并所需要的辅助数组

    @Override
    public void sort(Comparable[] a) {
        aux = new Comparable[a.length]; //一次性分配空间
        sort(a, 0, a.length - 1);
    }

    /**
     * 递归排序
     * @param a 数组
     * @param lo 起始点
     * @param hi 终止点
     */
    private void sort(Comparable[] a, int lo, int hi) {
        if (lo >= hi) {
            return;
        }

        int mid = lo + (hi - lo) / 2;
        sort(a, lo, mid);
        sort(a, mid + 1, hi);
        marge(a, lo, mid, hi);
    }

    /**
     * 归并结果
     * @param a 数组
     * @param lo 起始点
     * @param mid 中间点
     * @param hi 终止点
     */
    private void marge(Comparable[] a, int lo, int mid, int hi) {

        for (int k = lo; k <= hi; k++) { //复制一份
            aux[k] = a[k];
        }

        int i = lo;
        int j = mid + 1;

        //合并
        for (int k = lo; k <= hi; k++) {
            //取左右两边较小的值，如果左边用尽了则使用右边的元素。右边用尽，则反之
            if (i > mid) {
                a[k] = aux[j++];
            } else if (j > hi) {
                a[k] = aux[i++];
            } else if (less(aux[i], aux[j])) {
                a[k] = aux[i++];
            } else {
                a[k] = aux[j++];
            }
        }
    }
}
```

`end:2015-12-02 00:05:00`

### 2.2.2 自顶向下的归并排序
`start:2015-12-02 12:30`
sort() 方法的作用其实在于安排多次 merge() 方法调用的正确顺序。

归并排序是算法设计中分治思想的典型应用。

归并排序所需要的时间和 $N \lg N$ 成正比。

通过一些细致的思考我们还能够大幅度缩短归并排序的运行时间，如下：
- 2.2.2.1 对小规模子数组使用插入排序
- 2.2.2.2 测试数组是否已经有序
- 2.2.2.3 不讲元素复制到辅助数组

### 2.2.3 自底向上的归并排序
实现归并排序的另一种方法：先归并那些微型数组，然后在成对归并得到的子数组。

```java
    public void sort(Comparable[] a) {
        int N = a.length; //进行 lgN 次两两归并
        this.initAus(N);

        for (int sz = 1; sz < N; sz *= 2) { //sz 子数组大小
            for (int lo = 0; lo < N - sz; lo += 2 * sz) { //lo：子数组索引
                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
            }
        }
    }
```

自底向上的归并排序比较适合用链表组织的数据。

`end:2015-12-02 13:24`

### 2.2.4 排序算法的复杂度
`start:2015-12-02 22:19:00`

## 2.3 快速排序
快速排序是目前应用最广泛的排序算法。

流行的原因：
- 实现简单
- 适用于各种不同的输入数据
- 在一般应用中比其他排序算法快。

特点：它是原址排序算法。

缺点：非常脆弱，实现时要注意避免低劣的性能。

### 2.3.1 基本算法
快速排序是一种分治的排序算法。

`思想：` 举个例子，给一堆图书馆的书排序，方案是，先随便挑一本书，比这本书编号小的书，往左扔，大的往右边扔。 然后递归。即可排好序。


```java
public class Quick extends AbstractSortExample{
    @Override
    public void sort(Comparable[] a) {
        StdRandom.shuffle(a); //消除对输入的依赖
        sort(a, 0, a.length - 1);
    }

    private void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo)  return;
        int j = partition(a, lo, hi);
        sort(a, lo, j - 1);
        sort(a, j + 1, hi);
    }

    private int partition(Comparable[] a, int lo, int hi) {
        int i = lo; int j = hi + 1; //左右扫描指针
        Comparable v = a[lo]; //切分元素

        while (true) {
            //扫描左右，检查扫描是否结束并交换元素
            while (less(a[++i], v))  if (i == hi) break;
            while (less(v, a[--j])) if (j == lo)  break;
            if (i >= j) break;
            exch(a, i, j);
        }
        exch(a, lo, j);
        return j;
    }
}

```

注意事项：
- 2.3.1.1 原地切分：如果使用一个辅助数组，可以很容易实现切分，但需要花费开销复制回去，这会大大降低排序的速度
- 2.3.1.2 别越界：注意数组下标别越界了
- 2.3.1.3 保持随机：把原数组大乱掉
- 2.3.1.4 终止循环：
- 2.3.1.5 处理切分元素值有重复的情况
- 2.3.1.6 终止递归

### 2.3.2 性能特点
归并排序和希尔排序一般都比快速排序慢，原因在于他们内部循环中移动数据。

快速排序的最好情况是每次都正好能将数组对半分，这个递归公式的解 $Cn$~$N\lg n$

### 2.3.3 算法改进
快速排序是由 C.A.R Hoare 在1960 年发明的，之后人们不断提出了各种改进方法。不是所有的方法都可行，但其中有一些，非常有效。

以下改进意见值得参考，但需要通过实验来确定改进效果并为实现先择最佳的参数。一般来说他们能将性能提升 20%~30%

#### 2.3.3.1 切换到插入排序
和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点：
- 对于小数组，快速排序比插入排序慢
- 因为递归，快速排序的 sort() 方法在小数组中也会调用自己。

#### 2.3.3.2 三取样切分

#### 2.3.3.3 熵最优的排序
实际应用中经常会出现含有大量重复元素的数组。在有大量重复元素的情况下，快速排序就有很大的改进潜力。将当前实现的线性对数级的性能提高到线性级别。

一个简单的想法就是将数组切分为三部分，分别对应小于、等于喝大于切分元素的数组元素。

```java
public class Quick3way extends AbstractSortExample {
    @Override
    public void sort(Comparable[] a) {
        StdRandom.shuffle(a); //消除对输入的依赖
        sort(a, 0, a.length - 1);
    }

    private void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int lt = lo, i = lo + 1, gt = hi;
        Comparable v = a[lo];
        while (i <= gt) {
            int cmp = a[i].compareTo(v);
            if (cmp < 0) exch(a, lt++, i++);
            else if (cmp > 0) exch(a, i, gt--);
            else i ++;
        } //现在 a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi] 成立
        sort(a, lo, lt - 1);
        sort(a, gt + 1, hi);
    }
}
```

对于包含大量重复元素的数组，它将排序时间从先行对数级降低到线性级别。

这种对重复元素的适应性使得三向切分的快速排序称为排序库函数的最佳算法选择。

经过精心调优的快速排序在绝大多数计算机上的绝大多数应用中都会比其他基于比较的排序算法更快。

`end:2015-12-02 23:46`

## 2.4 优先队列
`start:2015-12-03 08:30`
优先级队列最重要的两个操作是：
- 删除最大元素
- 插入元素

### 2.4.3 堆的定义
数据结构二叉堆能够很好的实现优先级队列的基本操作。

当一棵二叉树的每个节点都大于等于它的两个子节点时，它被称为有序堆。
### 2.4.4 堆的算法
对于一个含有 N 个元素的基于对的优先队列，插入元素操作只需要不超过($\lg N+1$)次比较，删除最大元素的操作不需要超过 $2\lg N$次比较。
```java
public class MaxPQ<Key extends Comparable<Key>> {
    private Key[] pq; //pq[0] 不使用
    private int N = 0;

    public MaxPQ(int maxN) {
        pq = (Key[]) new Comparable[maxN + 1];
    }

    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }

    public void insert(Key v) {
        pq[++N] = v;
        swim(N);
    }

    public Key delMax() {
        Key max = pq[1]; //从根节点得到最大元素
        exch(1, N--);    //最大元素和最后一个元素交换，sink 将恢复堆的有序性
        pq[N + 1] = null; //防止对象游离
        sink(1); //回复堆的有序性
        return max;
    }

    private void sink(int k) {
        while (2 * k <= N) {
            int j = 2 * k;
            if (j < N && less(j, j + 1)) { j++; } //获取子节点中大的
            if (!less(k, j)) { break; }
            exch(k, j);
            k = j;
        }
    }

    public void swim(int k) {
        while (k > 1 && less(k / 2, k)) {
            exch(k / 2, k);
            k = k / 2;
        }
    }

    private void exch(int i, int j) {
        Key t = pq[i];
        pq[i] = pq[j];
        pq[j] = t;
    }

    private boolean less(int i, int j) {
        return pq[i].compareTo(pq[j]) < 0;
    }
}
```

`end:2015-12-03 09:29`

#### 2.4.4.3 多叉堆
`start:2015-12-03 12:40`
基于用数组表示的完全三叉树构造对并修改相应的代码并不困难。

#### 2.4.4.4 调整数组大小

#### 2.4.4.5 元素的不可变性

#### 2.4.4.6 索引优先队列

#### 2.4.4.7 索引优先队列用例
多向归并问题：将多个有序的输入流归并成一个有序的输出流。

### 2.4.5 堆排序
堆排序可以分为两个阶段：
- 堆的构造阶段：将原始数组放到堆中
- 下沉排序阶段：从堆中按照递减顺序去除所有元素得到排序结果。

#### 2.4.5.1 堆的构造
`end:2015-12-03 13:05`

`今天暂停，刚才看完了《三体》在看三体相关的东西。。`